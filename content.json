{"meta":{"title":"Choin的博客","subtitle":"人呢，活在世上最重要的就是开心啦","description":["Vue","axios","git","PhotoSwipe"],"author":"Choin","url":"http://www.wcy21k.com"},"pages":[],"posts":[{"title":"Vue的探索之旅","slug":"Vue","date":"2017-11-30T16:00:00.000Z","updated":"2017-12-11T08:51:18.336Z","comments":true,"path":"Vue/","link":"","permalink":"http://www.wcy21k.com/Vue/","excerpt":"什么是Vue? Vue.js也称为Vue，于2014年2月由尤雨溪开源并维护。是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。戳这里了解什么是“渐进式框架”和“自底向上增量开发的设计”","text":"什么是Vue? Vue.js也称为Vue，于2014年2月由尤雨溪开源并维护。是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。戳这里了解什么是“渐进式框架”和“自底向上增量开发的设计” Vue的核心数据绑定比如你改变一个输入框 Input 标签的值，会自动同步更新到页面上其他绑定该输入框的组件的值 组件化页面上小到一个按钮都可以是一个单独的文件.vue，这些小组件直接可以像乐高积木一样通过互相引用而组装起来 Vue有以下特点：&#x3000;● 是一个轻量级MVVM（Model-View-ViewModel）框架，和Angular、React类似&#x3000;● 数据驱动 + 组件化的核心思想&#x3000;● 通过简单的API实现响应式的数据绑定和组合的视图组件&#x3000;● 更容易上手、小巧官方文档官方手册 常用指令1、v-model实现双向数据绑定，实时监控数据变化，一般用于表单。12345678910&lt;input type=\"text\" v-model=\"content\"&gt;&lt;/input&gt;// 使用v-model指令将输入框的值与vue实例中的content进行绑定// 二者中的任一值发生变化，另一个值都会跟随变化export default &#123; data ()&#123; return&#123; content：\" \", &#125; &#125;&#125; 2、v-for用于遍历数组、对象等。v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。123456&lt;li v-for=\"item in items\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;使用v-for传入index以获取到当前索引值&lt;tr v-for=\"(item,index) in items\"&gt;&lt;!-- 序号 --&gt;&lt;td class=\"order\"&gt;&#123;&#123;parseInt(index)+1&#125;&#125;&lt;/td&gt; &lt;/tr&gt; 3、v-on ( 可缩写为@ )用于绑定事件，用法：v-on：事件=”函数”。123456789101112@click=\"name\" // 点击该元素执行name()&lt;p @click=\"name\"&gt;&lt;/p&gt;export default &#123; mounted () &#123; var _this = this; _this.name(); &#125;, methods: &#123; name () &#123; console.log (\"Hello，World！\") &#125;, &#125; 4、v-show用来显示或隐藏元素，v-show是通过display实现。当v-show的值为true时显示，为false时隐藏。123456789&lt;input type=\"text\" v-show=\"name\"&gt;&lt;/input&gt;export default &#123; data () &#123; return &#123; name：false, // false(隐藏)、true(显示) &#125; &#125;&#125; 5、v-bind ( 可缩写为： )数据的绑定。12345678&lt;img :src=\"src\"&gt;export default &#123; data ()&#123; return&#123; src：\" \", // url &#125; &#125;&#125; 6、特殊特性 ref如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素，可以使用其改变样式123&lt;p ref=\"more\" &gt;加载更多&lt;/p&gt;var _this = this;_this.$refs.more.style.color = \"#cf000d\"; 数据绑定双向数据绑定：&#x3000;&#x3000;使用v-model指令，前面已经提到过。单向数据绑定：&#x3000;&#x3000;使用两对大括号&#x3000;&#x3000;这个在之前也经常使用，但是有一个缺点，就是vue实例需要长时间编译时会在页面中出现（闪烁现象）。vue提供了一个解决办法：使用v-cloak配合css。123456// html内容&lt;div id=\"app\" v-cloak&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;// css内容[v-cloak] &#123; display: none;&#125; &#x3000;&#x3000;使用指令v-text、v-html&#x3000;&#x3000;v-text也可达到与使用v-cloak相同的效果。12// html内容&lt;div id=\"app\" v-text=\"msg\"&gt;&lt;/div&gt; &#x3000;&#x3000;v-html会将文本中的html解析为html标签，然后渲染到页面中。 123456// html内容&lt;div id=\"app\" v-html=\"msg\"&gt;&lt;/div&gt;// vue实例中data部分内容 data: &#123; msg: 'hello&lt;mark&gt;vue.js&lt;mark&gt;' &#125; 生命周期vue实例从创建到销毁的过程，称为生命周期，共有八个阶段。这八个阶段里分别有一个叫做钩子函数的实例选项。供用户在相应的阶段对其进行操作。123456789101112131415161718192021222324beforeCreate()&#123; // 组件实例刚刚创建，还未进行数据观测和事件配置 &#125;,created()&#123; // 实例已经创建完成，并且已经进行数据观测和事件配置 &#125;,beforeMount()&#123; // 模板编译之前，还没挂载 &#125;,mounted()&#123; // 模板编译之后，已经挂载，此时才会渲染页面，才能看到页面上数据的展示 &#125;,beforeUpdate()&#123; // 组件更新之前 &#125;,updated()&#123; // 组件更新之后 &#125;,beforeDestroy()&#123; // 组件销毁之前 &#125;,destroyed()&#123; // 组件销毁之后 &#125; 这几个钩子中，最常用的是created()与mounted()。 计算属性计算属性也是用来存储数据，但具有以下几个特点： ● 数据可以进行逻辑处理操作 ● 对计算属性中的数据进行监视 例如购物车结算场景，用户选中商品的总金额是根据商品数量、选中商品种类数和商品单价来动态改变的。在HTML中，我们只需要使用这个计算属性就可以来表示最终的商品总额。我们不需要关注这个变量的数值变化，totalPrice这个变量的逻辑写在对应的computed计算属性中。123456789101112computed:&#123; totalPrice()&#123; var _this = this; let total = 0; if(_this.selectBooks) &#123; _this.selectBooks.forEach((book) =&gt;&#123; total += book.price * book.count; &#125;) &#125; return total; &#125;&#125; 也许会有疑问，这个计算属性和定义一个method方法不是差不多么？计算属性 vs 方法将计算属性的get函数定义为一个方法也可以实现和计算属性类似的功能。那么二者之间有什么区别？区别一：计算属性是基于它的依赖进行实时更新的，方法则是调用才更新区别二：计算属性是有缓存的，只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。操作一个没有依赖项的值也是如此。官方文档给出了下面这个例子：12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 计算属性存在缓存，这里的now值不会发生变化。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wcy21k.com/tags/Vue/"}]},{"title":"git常用指令","slug":"Git","date":"2017-11-03T16:00:00.000Z","updated":"2017-12-11T08:50:44.794Z","comments":true,"path":"Git/","link":"","permalink":"http://www.wcy21k.com/Git/","excerpt":"Git是目前最先进的分布式版本控制系统,相较于例如 CVS 或者 Subversion 等集中式版本管理软件，Git 并不是将代码的所有修改历史保存在中心服务器中。在 Git 中取而代之的是，所有参与项目的开发者都拥有各自的代码完全拷贝，并在自己的拷贝上进行软件开发。","text":"Git是目前最先进的分布式版本控制系统,相较于例如 CVS 或者 Subversion 等集中式版本管理软件，Git 并不是将代码的所有修改历史保存在中心服务器中。在 Git 中取而代之的是，所有参与项目的开发者都拥有各自的代码完全拷贝，并在自己的拷贝上进行软件开发。 git分为&#x3000;&#x3000;●工作区：目前写代码的区域/实际编辑代码。&#x3000;&#x3000;●缓存区：写好代码之后通过git add将代码加入到缓存区，表示我对这些代码已经做了代码追踪管理，但是还没有提交到仓库，就像是临时存放，在我的日志里面看不到代码状态。&#x3000;&#x3000;●本地仓库：就是代码仓库，保存每一次的提交记录，在里面有个提交日志。&#x3000;&#x3000;●远程仓库：远程仓库就是个远程服务器。 常用git命令初始化新版本库：git init 全局设置：git config –global user.name “xzavier” git config –global user.email “xzavier.xxx.com” 克隆版本库：git clone “url” 查看分支：git branch 创建分支：git branch branch_nema 切换分支：git checkout branch_name 创建+切换分支：git checkout -b branch_name 合并某分支到当前分支：git merge branch_name 重命名分支：git branch -m branch_name branch_new_name //不会覆盖已经存在的分支 重命名分支：git branch -M branch_name branch_new_name //会覆盖已经存在的分支 删除分支：git branch -d branch_name 强制删除分支： git branch -D branch_name 删除远程分支： git push origin : branch_name //可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支 拉取代码：git pull orgin branch_name 查看更改：git status 查看更改细节：git diff file_name 查看谁修改过代码：git blame filename 回到上次修改：git reset –hard 添加单个文件：git add filename.js 添加所有js文件：git add *.js 添加所有文件：git add . 提交添加的文件：git commit -m “your description about this branch” 提交单个文件：git commit -m “your description about this branch” filename.js push分支：git push orgin your_branch_name 备份当前分支内容：git stash 查看历史记录：git log 创建标签：git tag 1.0.0 //标签无法重命名 显示标签列表：git tag 切出标签：git checkout 1.0.0 删除标签：git tag -d 1.0.0 查看git远程地址：git remote -v 更改远程git地址：git remote set -url origin https://github.com/USERNAME/OTHERREPOSITORY.git ; git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git 线上覆盖本地并放弃本地修改：git reset –hard origin/master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.wcy21k.com/tags/git/"}]},{"title":"npm常用指令","slug":"npm","date":"2017-11-02T16:00:00.000Z","updated":"2017-12-11T08:50:49.262Z","comments":true,"path":"npm/","link":"","permalink":"http://www.wcy21k.com/npm/","excerpt":"npm全称为Node Package Manager，是一个基于Node.js的包管理器，也是整个Node.js社区最流行、支持的第三方模块最多的包管理器。至今，npm已经管理约24万个由开发者、公司和社区创建的模块。","text":"npm全称为Node Package Manager，是一个基于Node.js的包管理器，也是整个Node.js社区最流行、支持的第三方模块最多的包管理器。至今，npm已经管理约24万个由开发者、公司和社区创建的模块。 npm官网链接 ● 安装nodejs的依赖包例如npm install express 就会默认安装express的最新版本，也可以通过在后面加版本号的方式安装指定版本，如npm install express@3.0.61npm install &lt;name&gt; ● 将包安装到全局环境中1npm install &lt;name&gt; -g ● 安装的同时，将信息写入package.json中项目路径中如果有package.json文件时，直接使用npm install方法就可以根据dependencies配置安装所有的依赖包这样代码提交到github时，就不用提交node_modules这个文件夹了。1npm install &lt;name&gt; -save ● 会引导你创建一个package.json文件，包括名称、版本、作者这些信息等1npm init ● 删除某个依赖 1npm remove &lt;name&gt; ● 更新某个依赖1npm update &lt;name&gt; ● 列出当前安装的了所有包1npm list ● 查看当前包的安装路径1npm root ● 查看全局的包的安装路径1npm root -g ● 帮助，如果要单独查看install命令的帮助，可以使用的npm help install1npm root -g","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://www.wcy21k.com/tags/npm/"}]},{"title":"axios基本用法","slug":"axios","date":"2017-11-01T16:00:00.000Z","updated":"2017-12-11T08:50:33.181Z","comments":true,"path":"axios/","link":"","permalink":"http://www.wcy21k.com/axios/","excerpt":"vue使用axios进行ajax请求 以前都用resource进行ajax请求，现在官方推荐使用axios，所以现在更换插件。这篇文章主要描写如何在项目中引入axios以及简单地使用axios进行ajax请求。","text":"vue使用axios进行ajax请求 以前都用resource进行ajax请求，现在官方推荐使用axios，所以现在更换插件。这篇文章主要描写如何在项目中引入axios以及简单地使用axios进行ajax请求。 官方文档第一步，需要通过npm安装axios插件1npm install --save axios 第二步，需要在项目中的入口js文件引入这个插件1234import Vue from 'vue'import axios from 'axios' Vue.use(axios) 第三步，在项目中使用axios进行ajax请求//写法112345Vue.axios.get(api).then((response)=&gt;&#123; console.log(response.data);//成功回调&#125;,(response)=&gt;&#123; //失败回调&#125;) //写法212345this.axios.get(api).then((response)=&gt;&#123; console.log(response.data);//成功回调&#125;,(response)=&gt;&#123; //失败回调&#125;) //写法3——-个人偏好12345this.$http.get(api).then((response)=&gt;&#123; console.log(response.data);//成功回调&#125;,(response)=&gt;&#123; //失败回调&#125;)","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wcy21k.com/tags/Vue/"},{"name":"ajax","slug":"ajax","permalink":"http://www.wcy21k.com/tags/ajax/"}]},{"title":"聊一聊BEM设计模式在Vue组件开发中的应用","slug":"BEM","date":"2017-10-31T16:00:00.000Z","updated":"2017-12-11T08:50:39.573Z","comments":true,"path":"BEM/","link":"","permalink":"http://www.wcy21k.com/BEM/","excerpt":"回想一下在你的前端生涯中是否遇到过以下问题1.在写css的时候经常会在命名class时绞尽脑汁2.在团队多人开发中出现css命名冲突3.在进行组件化开发时如何规范书写css 什么是BEMBEM是Yandex团队提出的一种css的命名方式，通过这种命名方式可以很好地解决上面遇到的问题，提高css的开发效率和可读性 进入BEM的世界 ● B: 表示块，可以抽象成一个组件 ● E: 表示元素，组件下的一个元素，多个元素形成一个组件 ● M:表示修饰符，可以用来表示元素的状态，比如激活状态，颜色，大小","text":"回想一下在你的前端生涯中是否遇到过以下问题1.在写css的时候经常会在命名class时绞尽脑汁2.在团队多人开发中出现css命名冲突3.在进行组件化开发时如何规范书写css 什么是BEMBEM是Yandex团队提出的一种css的命名方式，通过这种命名方式可以很好地解决上面遇到的问题，提高css的开发效率和可读性 进入BEM的世界 ● B: 表示块，可以抽象成一个组件 ● E: 表示元素，组件下的一个元素，多个元素形成一个组件 ● M:表示修饰符，可以用来表示元素的状态，比如激活状态，颜色，大小 BEM这货究竟张啥样呢，颜值高不高，请看下面的代码123.block &#123;&#125;.block__element &#123;&#125;.block__element--modifier &#123;&#125; 看完后你的内心会不会在想,卧槽，这货居然这么丑，名字还这么长，丑拒… __和–连接符这是什么鬼 ● __主要用来表示块(B)和元素(E)间的连接 ● –用来表示块或者元素与状态的连接 比如我们要做写一个button的组件，可以这么来 在Vue中结合Stylus预编译器使用BEM规范","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://www.wcy21k.com/tags/Vue/"}]},{"title":"深秋有感","slug":"fell","date":"2017-10-30T16:00:00.000Z","updated":"2017-12-11T08:51:32.454Z","comments":true,"path":"fell/","link":"","permalink":"http://www.wcy21k.com/fell/","excerpt":"&#x3000;&#x3000;10月31号，在脑海里一直认为万圣节这玩意儿在平安夜前一天，这几天才知道今天是万圣节，一个不给糖就捣蛋的节日！咳~ 每到了这个时候，天黑的也一天比一天早，下班了走在路上天已经黑蒙蒙了，背后传来同事的声音:”你不冷吗？”，咦？听声音怎么是个男的，”冷啊，不晓得几冷”，我回头看了他一眼，随后说这话的小伙子从我身边跑过，渐渐的，他的身影消失在黑夜里。","text":"&#x3000;&#x3000;10月31号，在脑海里一直认为万圣节这玩意儿在平安夜前一天，这几天才知道今天是万圣节，一个不给糖就捣蛋的节日！咳~ 每到了这个时候，天黑的也一天比一天早，下班了走在路上天已经黑蒙蒙了，背后传来同事的声音:”你不冷吗？”，咦？听声音怎么是个男的，”冷啊，不晓得几冷”，我回头看了他一眼，随后说这话的小伙子从我身边跑过，渐渐的，他的身影消失在黑夜里。回家的路上时不时身上打来一阵风，凉飕飕的，下意识的哆嗦下，双手插进裤兜，借着不远处驶来的汽车洒过来的灯光，踉跄的过着熙攘的马路，天渐凉。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.wcy21k.com/tags/随笔/"}]},{"title":"PhotoSwipe使用指南","slug":"PhotoSwipe","date":"2017-10-29T16:00:00.000Z","updated":"2017-12-11T08:51:07.412Z","comments":true,"path":"PhotoSwipe/","link":"","permalink":"http://www.wcy21k.com/PhotoSwipe/","excerpt":"前言PhotoSwipe不是一个简单的jQuery插件，至少我在这上面耗了点时间，希望这篇文章能让你的代码快一点，更快一点~~","text":"前言PhotoSwipe不是一个简单的jQuery插件，至少我在这上面耗了点时间，希望这篇文章能让你的代码快一点，更快一点~~ 介绍PhotoSwipe 是专为移动触摸设备设计的相册/画廊，兼容所有iPhone、iPad、黑莓6+,以及桌面浏览器.底层实现基于HTML/CSS/JavaScript,是一款免费开源的相册产品。官方网站：http://photoswipe.com/源码下载：https://github.com/dimsemenov/photoswipe国内CDN：http://www.bootcdn.cn/photoswipe/ 一、构建网页，引入相关文件123456&lt;!-- 引入PhotoSwipe CSS文件--&gt;&lt;link rel=\"stylesheet\" href=\"./photoswipe.min.css\"&gt;&lt;link rel=\"stylesheet\" href=\"./default-skin.min.css\"&gt;&lt;!-- 引入PhotoSwipe JS文件--&gt;&lt;script src=\"./photoswipe.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./photoswipe-ui-default.min.js\"&gt;&lt;/script&gt; 您可以在GitHub存储库的dist/文件夹中找到它们。Sass和未编译的JS文件位于文件夹src/中。如果您打算修改现有样式，建议使用Sass，因为有结构化和注释的代码。 二、将PhotoSwipe（.pswp）元素添加到DOM您可以通过JS（直接在初始化之前）动态添加HTML代码，或者最初在页面中添加HTML代码（如在演示页面上完成的）。此代码可以附加到任何地方，但最好在关闭之前body标签内。您可以将它重用于多个画廊（只要您使用相同的UI类）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt;&lt;div class=\"pswp\" tabindex=\"-1\" role=\"dialog\" aria-hidden=\"true\"&gt; &lt;!-- Background of PhotoSwipe. It's a separate element as animating opacity is faster than rgba(). --&gt; &lt;div class=\"pswp__bg\"&gt;&lt;/div&gt; &lt;!-- Slides wrapper with overflow:hidden. --&gt; &lt;div class=\"pswp__scroll-wrap\"&gt; &lt;!-- Container that holds slides. PhotoSwipe keeps only 3 of them in the DOM to save memory. Don't modify these 3 pswp__item elements, data is added later on. --&gt; &lt;div class=\"pswp__container\"&gt; &lt;div class=\"pswp__item\"&gt;&lt;/div&gt; &lt;div class=\"pswp__item\"&gt;&lt;/div&gt; &lt;div class=\"pswp__item\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --&gt; &lt;div class=\"pswp__ui pswp__ui--hidden\"&gt; &lt;div class=\"pswp__top-bar\"&gt; &lt;!-- Controls are self-explanatory. Order can be changed. --&gt; &lt;div class=\"pswp__counter\"&gt;&lt;/div&gt; &lt;button class=\"pswp__button pswp__button--close\" title=\"Close (Esc)\"&gt;&lt;/button&gt; &lt;button class=\"pswp__button pswp__button--share\" title=\"Share\"&gt;&lt;/button&gt; &lt;button class=\"pswp__button pswp__button--fs\" title=\"Toggle fullscreen\"&gt;&lt;/button&gt; &lt;button class=\"pswp__button pswp__button--zoom\" title=\"Zoom in/out\"&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class=\"pswp__preloader\"&gt; &lt;div class=\"pswp__preloader__icn\"&gt; &lt;div class=\"pswp__preloader__cut\"&gt; &lt;div class=\"pswp__preloader__donut\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"pswp__share-modal pswp__share-modal--hidden pswp__single-tap\"&gt; &lt;div class=\"pswp__share-tooltip\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class=\"pswp__button pswp__button--arrow--left\" title=\"Previous (arrow left)\"&gt; &lt;/button&gt; &lt;button class=\"pswp__button pswp__button--arrow--right\" title=\"Next (arrow right)\"&gt; &lt;/button&gt; &lt;div class=\"pswp__caption\"&gt; &lt;div class=\"pswp__caption__center\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 你可能会问，为什么PhotoSwipe不会通过JS自动添加这个代码 ? 官方给出的说法 — 只是为了保存文件大小，以防万一需要修改布局。如果不添加这串代码到你的DOM中，你的PhotoSwipe将不会有任何效果 ! 三、配置文件 分两种情况 ●图文混排(如下图) ●轮播图(如下图) ●图文混排123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var openPhotoSwipe = function () &#123;var imgss = $(\".book img\");/**此处是你定义图片的变量 *// imgss.each(function () &#123;// &#125;) var pswpElement = document.querySelectorAll('.pswp')[0]; var items = imgss.map(function () &#123; return &#123; src: $(this).attr('src'),/**获取src */ w: $(this).width() * 5,/**获取width并设置max缩放倍数 */ h: $(this).height() * 5 /**获取height并设置min缩放倍数 */ &#125; &#125;) // 以下是官方写法 // build items array // var items = [ // &#123; // src: $(this).attr('src'), // w: $(this).width(), // h: $(this).height() // &#125;, // ]; // define options (if needed) var options = &#123; // 索引:当前点击 index: Index, // history &amp; focus options are disabled on CodePen history: false, focus: false, // 图片间的间距 spacing: 0.05, //点击图片/黑边关闭 tapToClose: true, showAnimationDuration: 0, hideAnimationDuration: 0 &#125;; var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init();&#125;;$('.book img').click(function () &#123; // 获取到当前点击的索引 Index = $(this).index('img') - 1; openPhotoSwipe()&#125;) ●轮播图与图文混排格式的一致，有两点不同1.获取轮播图的所有图片，因swipe的loop属性(会自动增加开始和结束各1张图片，导致获取到的图片数目错误，即使用jQuery的not属性排除自动增加的图片)1var imgss = $(\".swiper-slide\").not(\".swiper-slide-duplicate\").find(\"img\"); 2.依然是swipe的loop属性，so~1Index = $(this).index('img') - 3; 成功后就是这样子啦~","categories":[],"tags":[{"name":"插件","slug":"插件","permalink":"http://www.wcy21k.com/tags/插件/"}]}]}